!function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=0)}([function(t,e,n){"use strict";n.r(e);const r=-1,i=-2,s=-3;function o(t,e){for(const n of e)t.add(n)}function*a(t,e){for(let n=t;n<e;n+=1)yield n}class f{constructor(t,e,n){this.array=t,this.ROWS=e,this.COLS=n,this.POINT_COUNT=e*n}getRow(t){return Math.floor(t/this.COLS)}getCol(t){return t%this.COLS}countStatus(t){let e=0;for(const n of this.array)n===t&&(e+=1);return e}splitUnknownParts(){const t=new Array(this.array.length);function e(n){return t[n]<0?n:t[n]=e(t[n])}t.fill(-1);const n=(n,r)=>{(function(t,e){return(t>=0||t===i)&&(e>=0||e===i)||t===e})(this.array[n],this.array[r])&&function(n,r){const i=e(n),s=e(r);i!==s&&(t[i]<t[s]?(t[i]+=t[s],t[s]=i):(t[s]+=t[i],t[i]=s))}(n,r)};for(const t of a(0,this.ROWS))for(const e of a(0,this.COLS)){const r=t*this.COLS+e,i=r-this.COLS,s=r-1,o=r-this.COLS-1;e>=1&&n(r,s),t>=1&&n(r,i),t>=1&&e>=1&&n(r,o)}const r=new Map;for(const t of a(0,this.POINT_COUNT)){const n=e(t);this.array[n]===s&&(r.has(n)?r.get(n).push(t):r.set(n,[t]))}return r.values()}*neighbors(t){const e=this.getRow(t),n=this.getCol(t);for(const t of[-1,0,1])for(const r of[-1,0,1]){const i=e+t,s=n+r;i>=0&&i<this.ROWS&&s>=0&&s<this.COLS&&(yield i*this.COLS+s)}}group(t){const e=[],n=[],o=[],a=[];for(const f of t)switch(this.array[f]){case r:e.push(f);break;case i:o.push(f);break;case s:n.push(f);break;default:a.push(f)}return{mines:e,unknowns:n,safes:o,normals:a}}apply(t,e){for(const n of t)this.array[n]=e}revert(t){this.apply(t,s)}check(t){for(const e of t){const{mines:t,unknowns:n}=this.group(this.neighbors(e)),r=t.length,i=t.length+n.length;if(!(r<=this.array[e]&&this.array[e]<=i))return!1}return!0}findRelated(t){const e=new Set;for(const n of t)for(const t of this.neighbors(n))this.array[t]>0&&e.add(t);return e}findExplicitMines(t){const e=new Set;let n;n=t?this.findRelated(t):Array.from(a(0,this.POINT_COUNT)).filter(t=>this.array[t]>0);for(const t of n){const{mines:n,unknowns:r}=this.group(this.neighbors(t));if(this.array[t]===r.length+n.length)for(const t of r)e.add(t)}return e}findExplicitSafes(t){const e=new Set;let n;n=t?this.findRelated(t):Array.from(a(0,this.POINT_COUNT)).filter(t=>this.array[t]>0);for(const t of n){const{mines:n,unknowns:r}=this.group(this.neighbors(t));if(this.array[t]===n.length)for(const t of r)e.add(t)}return e}explicitIterationFromSafe(t,e=!1){const n=new Set,s=new Set;let a=!1,f=t;for(;f.length>0;){const t=this.findExplicitMines(f);if(this.apply(t,r),o(n,t),e&&!this.check(this.findRelated(t))){a=!0;break}if(f=this.findExplicitSafes(t),this.apply(f,i),o(s,f),e&&!this.check(this.findRelated(f))){a=!0;break}}return{foundMines:n,foundSafes:s,checkFailed:a}}explicitIterationFromMine(t,e=!1){const n=new Set,s=new Set;let a=!1,f=t;for(;f.length>0;){const t=this.findExplicitSafes(f);if(this.apply(t,i),o(s,t),e&&!this.check(this.findRelated(t))){a=!0;break}if(f=this.findExplicitSafes(t),this.apply(f,r),o(n,f),e&&!this.check(this.findRelated(f))){a=!0;break}}return{foundMines:n,foundSafes:s,checkFailed:a}}canBeMine(t){this.array[t]=r;const{foundMines:e,foundSafes:n,checkFailed:i}=this.explicitIterationFromMine([t],!0);return this.array[t]=s,this.revert(e),this.revert(n),!i}canBeSafe(t){this.array[t]=i;const{foundMines:e,foundSafes:n,checkFailed:r}=this.explicitIterationFromSafe([t],!1);return this.array[t]=s,this.revert(e),this.revert(n),!r}canBeResolve(t){return this.group(this.neighbors(t)).normals.length>0}sortByNearbyNumbers(t,e){const n=this.group(this.neighbors(t)).normals,r=this.group(this.neighbors(e)).normals;return n.reduce((t,e)=>Math.min(t,this.array[e]),9)-r.reduce((t,e)=>Math.min(t,this.array[e]),9)}resolve(t){return this.canBeMine(t)?this.canBeSafe(t)?s:r:i}}function c(t){postMessage(JSON.stringify({type:"mine",value:Array.from(t)}))}function h(t){postMessage(JSON.stringify({type:"safe",value:Array.from(t)}))}onmessage=function(t){const e=JSON.parse(t.data);if("hint"!==e.type)throw new Error(`Invalid message type:${e.type}`);{const t=new f(e.array,e.ROWS,e.COLS),o=e.USE_AUTO,a=t.findExplicitMines();t.apply(a,r),c(a);const u=t.findExplicitSafes();t.apply(u,i),h(u);let l=u,p=null;t:for(;;){if(l){const{foundMines:e,foundSafes:n}=t.explicitIterationFromSafe(l);c(e),h(n),l=null}if(p){const{foundMines:e,foundSafes:n}=t.explicitIterationFromMine(p);c(e),h(n),p=null}if(0===t.countStatus(i))for(const e of t.splitUnknownParts()){e.sort(t.sortByNearbyNumbers.bind(t));for(const a of e){if(!t.canBeResolve(a))break;n=[a],postMessage(JSON.stringify({type:"danger",value:Array.from(n)}));const e=t.resolve(a);if(e!==s)if(e===i){if(t.apply([a],i),h([a]),o){l=[a];continue t}}else if(e===r&&(t.apply([a],r),c([a]),o)){p=[a];continue t}}}break}}var n}}]);